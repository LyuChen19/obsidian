#C语言 
# 一.数据类型介绍
## 1.概念
>- 所谓类型，就是相似的数据所拥有的共同特征，编译器只有知道了数据的类型，才能知道如何操作数据。
## 2.数据类型分类
>- **内置类型：字符，整型，浮点型，布尔类型
>- 自定义类型：数组，结构体-struct，枚举-enum，联合体-union**(自己创造类型)

^4a49f6

### a.字符类型
>- char
>- [signed]char-有符号的char
>- unsigned char-没有符号的char
### b.整型-int
>- <mark style="background: #FFB86CA6;">短整型</mark>
>	- short [int]
>	- [signed] short [int]
>	- unsigned short [int]
>- <mark style="background: #FFB86CA6;">整型</mark>
>	- int
>	- [signed] int
>	- unsigned int
>- <mark style="background: #FFB86CA6;">长整型</mark>
>	- long [int]
>	- [signed] int
>	- unsigned long[int]
>- <mark style="background: #FFB86CA6;">更长的整型</mark>
>	- long long [int]
>	- [signed] long long [int]
>	- unsigned long long [int]
>[]内的都可省略
### c.浮点型
>-类型
>	- float-单精度浮点型
>	- double-双精度浮点型
>	- long double-精度更高的浮点型
>- **在值不变的情况下，小数点可以浮动，因此小数被称为浮点型**
>- [[习题训练1：对应C语言常见概念#^e103fd|浮点型具体应用]]
### d.布尔类型
>- C语言是怎么表示真假的呢？
>	- 0 表示假；非0 表示真(C语言早期处理)
>	- 在C99中引入了布尔类型<mark style="background: #FFB86CA6;">_Bool</mark>
>	- **布尔类型是用来表示真假的类型**

- 使用布尔类型必须包含一个头文件<stdbppl.h>
- 布尔类型变量的取值是：ture或者false
布尔类型三种![[Pasted image 20230723003717.png]]
---
# 二.signed和unsigned
## 1.概念
>- signed和unsigned是用来修饰字符型和整型的关键字
>- **signed**关键字，表示一个类型带有正负号，包含负值；
>	- 温度等有正有负
>- **unsigned**关键字，表示该类型不带有正负号，只能表示零和正数
>	- 年龄等是绝对的正数
## 2.区别与应用
- **对于int类型，默认是带有正负的，也就是说int等同于signed int。**
>- <mark style="background: #FFB86CA6;">整数变量</mark>声明为unsigned的好处是，同样长度的内存能够表示的最大整数值，增大了一倍
>- <mark style="background: #FFB86CA6;">char类型</mark>默认是否带有正负号，由当前系统决定，也就是说char类型既可以是signed char，也可以是unsigned char，这点与int不同
---
# 三.数值类型的取值范围
>- **limits.h文件中说明了整数类型的取值范围；**
>- **float.h这个头文件中说明浮点型类型的取值范围。**
## 短整型比整型要小一些的本质
>![[Pasted image 20230723081114.png]]
>- **占内存空间越大所能存放的数据就越多**
>- sizeof是一个操作符，计算的是变量所占内存的大小，单位是字节；计算的是类型创建的变量所占内存的大小，单位是字节。
>	- sizeof所计算返回值的类型是size_t，size_t的本质是unsigned int(无符号整型)
>	- size_t类型数据在打印时，格式应该使用%zd(**由此可知在未来打印无符号整型时，既可以用unsigned int，也可以用size_t**)
>- C语言标准规定：sizeof(long)>=sizeof(int)，sizeof(long)可以表示四个字节或八个字节，所以在用sizeof(long)表示八个字节时会掉链子，在这时候最好使用long long

^d0a1f0

---
# 四.变量
## 1.变量的创建
>- <mark style="background: #FFB86CA6;">概念</mark>：首先我们要了解，**类型是用来创建变量的**。C语言中把经常变化的值称为**变量**，不变的值称为**常量**。
>- <mark style="background: #FFB86CA6;">变量创建的语法形式</mark>：![[Pasted image 20230723083351.png]]
>	- 例如，int age//整型变量      char ch//字符变量      double weight//浮点型变量
>	- **在创建变量的时候就给一个初始值，就叫初始化**
>		- 例如，int weight = 59；
>		- **对于浮点型类型，编译器会默认小数是double类型，如果想让小数是float类型的话，在小数加上f即可**。
## 2.变量的分类
>- <mark style="background: #FFB86CA6;">全局变量</mark>：在大括号外部定义的变量。适用范围更广，整个工程想使用都是有办法是用的。
>- <mark style="background: #FFB86CA6;">局部变量</mark>：在大括号内部定义的变量。只局限于局部范围内的使用。
>- **当局部变量与全局变量同名时，互补变量优先使用**。
>- 在学习C/C++语言时，我们会关注内存中的这三个区域：**栈区，堆区，静态区**。
>	- 局部变量函数参数放在**栈区**
>	- 全局变量函数参数放在**静态区**
>	- **堆区**是用来动态内存管理
---
# 五.scanf和printf
## 1.printf函数

^5bdad0

### a.基本用法
>- [[C语言常见概念#^74afe4|printf]]
>- printf() 不会在⾏尾⾃动添加换⾏符，运⾏结束后，光标就停留在输出结束的地⽅，不会⾃动换⾏。为了让光标移到下⼀⾏的开头，可以在输出⽂本的结尾，添加⼀个换⾏符 \n 。
### b.占位符

^3acae8

>- 所谓占位符，就是这个位置可以被他后面的值替换。
>- **占位符的第一个字符一律为%，第二个字符为占位符类型**
>- 文本中可以有多个占位符，占位符的个数与后面代替的值是一一对应的
### c.常用占位符列举
![[Pasted image 20230723093231.png]]
- 指针的打印一般以16进制形式呈现
### d.输出格式
>- printf()可以定制占位符的输出格式
>- <mark style="background: #FFB86CA6;">限定宽度</mark>:printf()允许限定占位符的**最小宽度**
>	- 如果不满最小宽度，对应的值的前⾯会添加空格。 输出的**值默认是右对⻬**，即输出内容前⾯会有空格；如果希望改成左对⻬，在输出内容后⾯添加空 格，可以在占位符的 % 的后⾯插⼊⼀个 - 号。
>	- 对于⼩数，这个限定符会限制所有数字的最⼩显⽰宽度。%12f 表⽰输出的浮点数最少要占据12位。**由于⼩数的默认显⽰精度是⼩数点后6位**， 所以 123.45 输出结果的头部会添加2个空格。
>- <mark style="background: #FFB86CA6;">总是显示正负号</mark>：默认情况下， printf() 不对正数显⽰ + 号，只对负数显⽰ - 号。如果想让正数也输出 + 号，可 以在占位符的 % 后⾯加⼀个 + 。
>- <mark style="background: #FFB86CA6;">限制小数位数</mark>：输出⼩数时，有时希望限定⼩数的位数。举例来说，希望⼩数点后⾯只保留两位，占位符可以写 成 %.2f 。
>	- 最⼩宽度和⼩数位数这两个限定值，都可以⽤ * 代替，通过 printf() 的参数传⼊。![[Pasted image 20230723094608.png]]
>- <mark style="background: #FFB86CA6;">输出部分字符串</mark>：%s 占位符⽤来输出字符串，默认是全部输出。如果只想输出开头的部分，可以⽤ %.[m]s 指定输出 的⻓度，其中 [m] 代表⼀个数字，表⽰所要输出的⻓度。占位符 %.5s 表⽰只输出字符串“hello world”的前5个字符，即“hello”。
## 2.scanf

^a8cc68
- [[scanf的连续输入]]
>- 我们需要给变量输入值是就可以使用scanf函数，将变量的值输出在屏幕上 的时候可以使⽤ printf 函数。
>- 对于scanf函数`scanf("%d",&score)`前边是数值，后边**必须是取地址，数组不需要取地址**.
>- scanf() 处理数值占位符时，**会⾃动过滤空⽩字符，包括空格、制表符、换⾏符等**。 所以，⽤⼾<mark style="background: #FF5582A6;">输⼊的数据之间</mark>，**有⼀个或多个空格不影响 scanf() 解读数据**。另外，⽤⼾使⽤回⻋键，将输⼊分成⼏⾏，也不影响解读
### a.读取原理
>scanf() 处理⽤⼾输⼊的原理是，⽤⼾的输⼊**先放⼊缓存**，等到**按下回⻋键后**，按照占位符对缓存 进⾏解读。 解读⽤⼾输⼊时，会从上⼀次解读遗留的第⼀个字符开始，直到读完缓存，或者**遇到第⼀个不符合条件的字符为⽌**。
### b.scanf的返回值
>	- scanf() 的返回值是⼀个**整数**，表⽰**成功读取的变量个数**。
>	- 如果没有读取任何项，或者匹配失败，则返回0。如果在成功读取任何数据之前，发⽣了读取错误或者遇到读取到⽂件结尾，则返回常量**EOF**。
### c.scanf中占位字符特殊应用
>- <mark style="background: #FFB86CA6;">scanf中的%c字符</mark>：
>	- 除了 %c 以外，都会⾃动忽略起⾸的空⽩字符。 **%c 不忽略空⽩字符，总是返回当前第⼀个字符，⽆论该字符是否为空格**。
>	- 如果要强制跳过字符前的空⽩字符，可以写成 `scanf(" %c", &ch) `，即 %c 前加上⼀个空格，表 ⽰跳过零个或多个空⽩字符。
>-<mark style="background: #FFB86CA6;"> scanf中的%s</mark>：
>	- 它其实不能简单地等同于字符串。它的规则是，从当前第⼀个⾮空⽩字符开始读起，直到遇到空⽩字符（即空格、换⾏符、制表符等为⽌。
>	- 因为 %s **不会包含空⽩字符**，所以⽆法⽤来读取多个单词，除⾮多个 %s ⼀起使⽤。这也意味着， **scanf() 不适合读取可能包含空格的字符串**
>	- scanf() 遇到 %s占位符，会在字符串变量末尾存储⼀个空字符 \0 。
### d.scanf函数的不安全之处
>- **scanf() 将字符串读⼊字符数组时，不会检测字符串是否超过了数组⻓度**。所以，储存字符串时， 很可能会超过数组的边界，导致预想不到的结果。
>	- <mark style="background: #FFB86CA6;">解决方法</mark>：为了防⽌这种情况，使⽤ %s 占位符时，应该**指定读⼊字符串的最⻓⻓度，即写成 %[m]s ，其中的 [m] 是⼀个整数，表⽰读取字符串的最大长度，后面的字符将被丢弃**。
### e.赋值忽略符

^7f78ed

>**例如，如果⽤⼾输⼊ 2020-01-01 ，就会正确解读出年、⽉、⽇。问题是⽤⼾可能输⼊其他 格式，⽐如 2020/01/01 ，这种情况下， scanf() 解析数据就会失败。**
>- 为了避免这种情况，**scanf() 提供了⼀个赋值忽略符（assignment suppression character） * 。 只要把 * 加在任何占位符的百分号后⾯，该占位符就不会返回值，解析后将被丢弃**。![[Pasted image 20230723105746.png]]
# 六.强制转换符
![[Pasted image 20230723110754.png]]
两边的类型不一样，这时候就会触发警告，为了消除这个警告，我们可以使用**强制转换符**：![[Pasted image 20230723110920.png]]
意思是将3.14强制类型转换为int类型，这种强制类型转换只取整数部分。尽量不要使用。
#C语言 #复盘 
# 1.EOF的意义及用法(while(scanf("%d",&n) != EOF))
#EOF
EOF，为End Of File的缩写，通常在文本的最后存在此字符表示资料结束。

在微软的DOS和Windows中，读取数据时终端不会产生EOF。此时，应用程序知道数据源是一个终端（或者其它“字符设备”），并将一个已知的保留的字符或序列解释为文件结束的指明；最普遍地说，它是[ASCII码](https://so.csdn.net/so/search?q=ASCII%E7%A0%81&spm=1001.2101.3001.7020)中的替换字符（Control-Z，代码26）。

**在C语言中**，或更精确地说成C标准函数库中表示文件结束符（end of file）。在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。在文本文件中，数据都是以字符的ASCII代码值的形式存放。我们知道，ASCII代码值的范围是0~127，不可能出现-1，因此可以用EOF作为文件结束标志。

档案存取或其它 I/O 功能可能传回等于象征符号值 (巨集) EOF 指示档案结束的情形发生。实际上 EOF 的值通常为 -1，但它依系统有所不同。巨集 EOF会在编译原始码前展开实际值给预处理器。

C语言中，EOF常被作为文件结束的标志。还有很多文件处理函数处错误后的返回值也是EOF，因此常被用来判断调用一个函数是否成功。

例如：

```
#include <stdio.h>
int main(){
    int n;
while(scanf("%d",&n) != EOF){

}
    return 0;
}

```

当上面的程序运行时，如果不加" != EOF“，那么这个程序就是个死循环，会一直运行下去；加上” != EOF“后该程序就不是死循环了，如果在终端不进行输入该程序会自动结束(while的意思就是说当当前输入缓存还有东西时就一直读取，直到输入缓存中的内容为空时停止)。

在这”scanf(“%d”,&n) != EOF“相当于”scanf(“%d”,&n) != EOF“，或”~scanf(“%d”,&n)“，或”scanf(“%d”,&n) == 1 " 。scanf的返回值由后面的参数决定

有小伙伴会问到上面那个程序怎么结束呢？

要注意的是：在终端(黑框)中手动输入时，系统并不知道什么时候到达了所谓的“文件末尾”，因此需要用<Ctrl + z>组合键然后按 Enter 键的方式来告诉系统已经到了EOF，这样系统才会结束while.

**scanf(“%d%d”, &a, &b);**

如果a和b都被成功读入，那么scanf的返回值就是2；如果只有a被成功读入，返回值为1；如果a和b都未被成功读入，返回值为0；如果遇到错误或遇到end of file，返回值为EOF，且返回值为int型。

**但是在C++中不存在这种用法，但相同作用的有while((cin >> a) != 0)：**

以前不理解在while里面用cin >> a;是什么意思，cin是C++的输入流对象，“>>”是重载的运算符，cin>>的返回值是cin对象。用这个当条件的话，通过检测其流的状态来判断结束；

（1）若流是有效的，即流未遇到错误，那么检测成功；

（2）若遇到文件结束符，或遇到一个无效的输入时（例如本题输入的值不是一个整数），istream对象的状态会变为无效，条件就为假；读取失败的时候，就不能继续读取了，那么读取操作结束，while(cin>>a)就返回false，跳出循环！

**C++中的while (cin>>n,n)：**

他的作用是：输入一个数，这数不为0时进入循环，为0时跳出循环。

> 采纳：“[https://www.cnblogs.com/tgycoder/p/4958519.html”](https://www.cnblogs.com/tgycoder/p/4958519.html%E2%80%9D)

输入（cin）缓冲是行缓冲。当从键盘上输入一串字符并按回车后，这些字符会首先被送到输入缓冲区中存储。每当按下回车键后，cin 就会检测输入缓冲区中是否有了可读的数据，这种情况下cin对键盘上是否有作为流结束标志CTRL+Z或者CTRL+D，其检查的方式有两种：阻塞式以及非阻塞式。

阻塞式检查方式指的是只有在回车键按下之后才对此前是否有 Ctrl+Z 组合键按下进行检查，非阻塞式样指的是按下 Ctrl+D 之后立即响应的方式。如果在按 Ctrl+D 之前已经从键盘输入了字符，则 Ctrl+D的作用就相当于回车，即把这些字符送到输入缓冲区供读取使用，此时Ctrl+D不再起流结束符的作用。如果按 Ctrl+D 之前没有任何键盘输入，则 Ctrl+D 就是流结束的信号。

阻塞式的方式有一个特点：只有按下回车之后才有可能检测在此之前是否有Ctrl+Z按下。

---
# 2.C/C++中对于负数的取模(%)运算_c++负数取模
## 0. 对于正数的取模运算

大前提是，取模运算的运算对象一定是整数。

当被除数和除数均为正整数时，取模运算遵循的法则为：`A % B`即为B整除A后的余数，如`5 % 2`的结果为`1`，`6 % 10`的结果为`6`。

## 1. 对于负数的取模运算

网上有取模的公式，我在这里先给出公式：

`A % B = A - A / B * B`

公式计算会相对复杂一些，其实可以借助**C99标准**来简单记忆负数的取模运算规律：

**取模运算结果的正负是由左操作数的正负决定的。如果%左操作数是正数，那么取模运算的结果是非负数；如果%左操作数是负数，那么取模运算的结果是负数或0。**

也就是说，在进行有负数参与的取模运算时，我们可以这样做：先将被除数和除数都按照正数来进行运算，然后观察被除数(左操作数)的正负，若被除数为正，则运算结果为正，若被除数为负，则运算结果为负。运算结果的正负与右操作符无关。

下面借助代码来实际验证一下：

```cpp
#include <iostream>using namespace std;int main(){    cout << 5 % 2 << endl;    cout << 5 % -2 << endl;    cout << -5 % 2 << endl;    cout << -5 % -2 << endl;    return 0;}
```

输出结果为

```cpp
11-1-1
```

---
# printf
[[C语言 数据类型和变量#^5bdad0|printf函数]] #复盘 #训练 
——printf()的作用是将参数文本输出到屏幕。它名字里面的f代表format（格式化），表示可以定制输出文本的格式。

——printf()不会在行尾自动添加换行符，运行结束后，光标就停留在输出结束的地方，不会自动换行。

——printf()可以在输出文本中指定占位符,“占位符”，就是这个位置可以用其他值代入。

——<mark style="background: #FFB86CA6;">printf()参数与占位符是一一对应关系，如果有n个占位符，printf()的参数就应该有n+1个。 如果参数个数少于对应的占位符， printf () 可能会输出内存中的任意值。</mark>

——`printf()`允许限定占位符的**最小宽度**。`%5d`表示这个占位符的宽度至少为5位。如果不满5位，对应的值的前面会添加空格。如果超过5位，正常输出就行，5是最少输出5位。
————————————————
